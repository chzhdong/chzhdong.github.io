---
title: Redis
published: 2025-02-06
description: 'Redis Tutorial'
image: ''
tags: ["Redis"]
category: 'Tool'
draft: false 
lang: 'zh_CN'
---

## 简介

Redis 是一个高性能的 key-value 数据库，其支持多种数据类型，包括 String、Hash、List、Set、Ordered Set，通过 Redis 可以缓解直接访问数据的压力，提升应用服务的效率。

## 可靠性

为了保障 Redis 的可靠性，可以通过搭建主从集群来实现数据的备份；

对于集群中数据的同步，可以分为全量同步和增量同步；初始化时一般为全量同步，即通过 RDB 文件直接传输全部数据给从节点进行同步，而增量同步则仅传输差异的数据进行数据同步；

为了实现增量同步，repl_baklog 是一个环形的队列，通过比较主从节点之间的 offset 来了解节点之间数据同步情况；

为了优化 Redis 的主从同步，可以减少单节点的负载，减少 RDB 的 IO 瓶颈；提升 repl_baklog 的大小，防止主从之间 offset 的数据覆盖；

## 哨兵

为了保障 Redis 集群的稳定性，通过设置哨兵来实现对应的故障恢复；哨兵会监控 Redis 集群中服务器的状态，如果发现主节点异常，则认为主观下线；当主观下线的数量超过阈值，则设置为客观下线；

之后，哨兵之间会执行推举，选出一个 leader，并由 leader 来执行对应的 failover 方法，重新设置 master 节点，并通知其他的节点；当之前的主节点恢复之后，会作为当前主节点的从节点。

## 数据结构

在 Redis 中，存储的基本数据结构是跳表，在跳表中数据是有序排放的，通过跳表可以快速的查找到所需数据；

对于 OrderedSet，是基于两种数据结构来实现的，包括 HashTable 来实现数据和分数的映射，而对于分数查找元素，则是通过跳表来实现快速查找的。

## 内存回收

对于 Redis 中内存回收的机制，可以通过 expire 设置对应的过期时间；在 Redis 中，保存着两个字典，即 key-value 和 key-expire 的数据，通过查找对应的 key 所对应的过期时间来处理；由两种过期处理的方法，即惰性删除和周期删除，惰性删除就是在访问到数据时查询其是否过期，并判断是否删除；周期删除则是周期性的挑选 key 进行检查，并删除过期的数据。

对于内存超过阈值的情况，就要通过内存淘汰来减少内存占用；在 Redis 中实现了多种方法，如 LRU、LFU、Random 等多种方法；其中 LRU 是最近访问时间，而 LFU 是最近访问频率，其中这个频率是逻辑访问频率，而并非真正的访问频率。

## 高并发缓存场景

### 缓存一致性

我们先看下目前企业用的最多的缓存模型。缓存的通用模型有三种：

- `Cache Aside`：有缓存调用者自己维护数据库与缓存的一致性。即：
  - 查询时：命中则直接返回，未命中则查询数据库并写入缓存
  - 更新时：更新数据库并删除缓存，查询时自然会更新缓存
- `Read/Write Through`：数据库自己维护一份缓存，底层实现对调用者透明。底层实现：
  - 查询时：命中则直接返回，未命中则查询数据库并写入缓存
  - 更新时：判断缓存是否存在，不存在直接更新数据库。存在则更新缓存，同步更新数据库
- `Write Behind Cahing`：读写操作都直接操作缓存，由线程异步的将缓存数据同步到数据库

### 缓存穿透

由于数据库中不存在该数据，那么缓存中肯定也不存在。因此不管请求该数据多少次，缓存永远不可能建立，请求永远会直达数据库。

解决方案有两种：

- 返回空值；
- 布隆过滤器；

### 缓存雪崩

缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

常见的解决方案有：

- 给不同的Key的TTL添加随机值，这样KEY的过期时间不同，不会大量KEY同时过期
- 利用Redis集群提高服务的可用性，避免缓存服务宕机。
- 给缓存业务添加降级限流策略。
- 给业务添加多级缓存，比如先查询本地缓存，本地缓存未命中再查询Redis，Redis未命中再查询数据库。

### 缓存击穿

**缓存击穿**问题也叫**热点Key**问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

常见的解决方案有两种：

- 互斥锁：给重建缓存逻辑加锁，避免多线程同时指向
- 逻辑过期：热点key不要设置过期时间，在活动结束后手动删除。
